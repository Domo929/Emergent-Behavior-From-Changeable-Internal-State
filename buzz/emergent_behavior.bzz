
SEN_APERTURE_DEG = 5.0
SEN_APERTURE_SPLIT_RAD = 0.5* SEN_APERTURE_DEG * math.pi / 180.0

SEN_DIST_CM = 300

CUR_STATE = 0


speed = 0.0

# (Type)(Reading)(State)
genome = {
    .0  = 0.0, #s'00
    .1  = 1.0, #vl00
    .2  = 1.0, #vr00
    .3  = 0.0, #s'01
    .4  = 1.0, #vl01
    .5  = 1.0, #vr01
    .6  = 0.0, #s'10
    .7  = 1.0, #vl10
    .8  = 1.0, #vr10
    .9  = 0.0, #s'11
    .10 = 1.0, #vl11
    .11 = 1.0, #vr11
    .12 = 0.0, #s'20
    .13 = 1.0, #vl20
    .14 = 1.0, #vr20
    .15 = 0.0, #s'21
    .16 = 1.0, #vl21
    .17 = 1.0  #vr21
}

### BUZZ FUNCTIONS ##
function init() {
	CUR_STATE = id % 2
	cur_x = pose.position.x
	cur_y = pose.position.y
	cur_z = pose.orientation.yaw
	cur_s = CUR_STATE
	cur_r = 0
	cur_speed = 0
}


function step() {
    #printGenome()
	neighbors.broadcast("state", CUR_STATE)
	var reading = sensor()
	updateFields(reading)
	if (CUR_STATE == 0) {
		if(reading == 0) {
		    CUR_STATE = genomeToState(genome[0])
			set_wheels(genome[1], genome[2])
			speed = calcSpeed(genome[1], genome[2])
		} else if (reading == 1) {
			CUR_STATE = genomeToState(genome[6])
            set_wheels(genome[7], genome[8])
            speed = calcSpeed(genome[7], genome[8])
		} else {
			CUR_STATE = genomeToState(genome[12])
            set_wheels(genome[13], genome[14])
            speed = calcSpeed(genome[13], genome[14])
		}
	} else { #CUR_STATE == 1
		if(reading == 0) {
			CUR_STATE = genomeToState(genome[3])
            set_wheels(genome[4], genome[5])
            speed = calcSpeed(genome[4], genome[5])
		} else if (reading == 1) {
			CUR_STATE = genomeToState(genome[9])
            set_wheels(genome[10], genome[11])
            speed = calcSpeed(genome[10], genome[11])
		} else {
			CUR_STATE = genomeToState(genome[15])
            set_wheels(genome[16], genome[17])
            speed = calcSpeed(genome[16], genome[17])
		}
	}
}

function genomeToState(genome){
    if (genome >= 5.0){
        return 1
    }
    return 0
}

function calcSpeed(vl, vr){
    return (vl + vr) / 2.0;
}

function printGenome(){
    log("ID: ", id, " ", genome[0], " ", genome[1]," ", genome[2])
}

function sensor(){
	closest_dist = 2*SEN_DIST_CM
	closest_rid = -1
	neighbors.foreach(
		function(rid, data){
			if (data.distance < SEN_DIST_CM) {
				if ((data.azimuth > -SEN_APERTURE_SPLIT_RAD) and (data.azimuth < SEN_APERTURE_SPLIT_RAD)) {
					if (data.distance < closest_dist) {
						closest_dist = data.distance
						closest_rid = rid
					}
				}
			}
		})
	var target_state = -1
	neighbors.listen("state", 
		function(vid, value, rid){
			if (rid == closest_rid) {
				target_state = value
			}
		})
	if (closest_rid == -1) {
		return 0
	} else if (target_state == CUR_STATE) {
		return 1
	} else {
		return 2
	}

}

function updateFields(sensor_reading) {
	cur_x = pose.position.x
	cur_y = pose.position.y
	cur_z = pose.orientation.yaw
	cur_s = CUR_STATE
	cur_r = sensor_reading
	cur_speed = speed

}

function reset() {
}

function destroy() {
}